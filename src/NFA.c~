#include "NFA.h"
#include "global.h"
#include "typedef.h"
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>

static int  OutPri[128] ;

static int  InPri[128] ; 

void PriorityInit( )
{
    InPri[ (int)'(' ] = 0; InPri[ (int)'|' ] = 3; InPri[ (int)'.'] = 5 ;
    InPri[ (int)'*' ] = 7; InPri[ (int)'+' ] = 7; InPri[ (int)'?'] = 7 ;

    OutPri[ (int)')' ] = 1; OutPri[ (int)'|' ] = 2; OutPri[ (int)'.' ] = 4;
    OutPri[ (int)'*' ] = 6; OutPri[ (int)'+' ] = 6; OutPri[ (int)'?' ] = 7;
    OutPri[ (int)'(' ] = 8;
}

int InPriority( xchar_t c )
{
    return InPri[ (int)c ] ;
}

int OutPriority( xchar_t c )
{
    return OutPri[ (int)c ] ;
}

NFA *CreateOneNFA( xchar_t c )
{
    NFA *nfa ;
    
    Edge *e ;

    nfa = malloc( sizeof( NFA ) );
    isNullPointer( nfa );

    /* 初始化唯一的两个状态点 */
    {
    nfa -> start = allocStatus();
    nfa -> start -> ID = 1;
    nfa -> start -> numOfOutEdges = 1;
    nfa -> start -> OutEdges = malloc( sizeof( Edge* ) * 
                                nfa -> start -> numOfOutEdges ) ;
    nfa -> start -> OutEdges[ 0 ] = e ;

    nfa -> end   = allocStatus();
    nfa -> end -> ID = 2;
    nfa -> end -> InEdges = malloc( sizeof( Edge* ) * 
                                nfa -> end -> numOfInEdges ) ;
    nfa -> end -> numOfInEdges = 1;
    nfa -> end -> InEdges[ 0 ] = e ;
    nfa -> end -> FinalStatus = true ;
    }
    /* 初始化唯一的边 */
    {
    e = malloc( sizeof( Edge ) );
    e -> from_Status = nfa -> start ;
    e -> to_Status = nfa -> end ;
    e -> matchContent = malloc( 1 ) ;
    e -> matchContent[ 0 ] = c ;
    }

    /* 初始化nfa的Edge数组 */
    {
    nfa -> numOfEdges = 1 ;
    nfa -> edgeArray = malloc( sizeof(Edge*) * nfa->numOfEdges );
    nfa -> edgeArray[ 0 ] = e ; 
    }
    /* 初始化nfa的Status状态数组 */
    {
        nfa -> numOfStatus = 2;
        nfa -> Status = malloc( sizeof(Status*) * nfa->numOfStatus ) ;
        isNullPointer( nfa->Status ); 
        nfa -> Status[ 0 ] = nfa -> start ;
        nfa -> Status[ 0 ] -> ID = 0;
        nfa -> Status[ 1 ] = nfa -> end ;
        nfa -> Status[ 1 ] -> ID = 1;
    }

    nfa -> numOfStatus = 2 ;
    return nfa ;
}

void 
linkTwoStatus_by_AnEdge( Status *fromS , 
                         Status *toS ,
                         Edge   *e
                        )
{
    if( !e || !fromS || !toS )
        return ;
    e -> from_Status = fromS ;
    e -> to_Status = toS ;
    
    fromS -> OutEdges = realloc( fromS -> OutEdges, sizeof(Edge*) ) ;
    fromS -> OutEdges[ fromS->numOfOutEdges ++ ] = e ;
    toS -> InEdges = realloc( toS -> InEdges, sizeof( Edge* ) ) ;
    toS -> InEdges[ toS -> numOfInEdges ++ ] = e ;

}

Edge*   allocEpsilonEdge( )
{
    Edge *e ;
    e = malloc( sizeof(Edge ));
    if (!e ) 
        return NULL ;
    e -> hasEpsilon = true ;
    return e ;
}

Status*
allocStatus( ){
    Status *s;
    s = malloc( sizeof(Status) );
    isNullPointer( s ) ;
    return s;
}

NFA *Link ( NFA *frontNFA, NFA *tailNFA )
{
    int i, j, numStatus ;
    NFA *combined_NFA;
    NFA *frontNFAcopy, *tailNFAcopy ;
    Edge *e ;

    e = malloc( sizeof(Edge) * 1 ) ;
    e -> hasEpsilon = true ;
    
    //StatusIDPlus( tailNFA, frontNFA -> numOfStatus ) ;
    frontNFAcopy = CopyNFA( frontNFA );
    tailNFAcopy = CopyNFA( tailNFA );

    frontNFAcopy -> end -> FinalStatus = false ;
    tailNFAcopy -> end -> FinalStatus = false ;
    linkTwoStatus_by_AnEdge( frontNFAcopy->end, tailNFAcopy->start, e ) ;

    combined_NFA = malloc( sizeof( NFA ) ) ;
    combined_NFA -> start = frontNFAcopy -> start ;
    combined_NFA -> end = tailNFAcopy -> end ;
    combined_NFA -> end -> FinalStatus = true ;

    /* 构造合成nfa的状态数组 */
    numStatus = frontNFAcopy -> numOfStatus + tailNFAcopy -> numOfStatus ;
    combined_NFA -> numOfStatus = numStatus ;
    combined_NFA -> Status = malloc( sizeof(Status*) * numStatus);

    for( i = 0; i < numStatus; i++ )
    {
        if( i < frontNFAcopy -> numOfStatus )
        {
            combined_NFA -> Status[ i ] = frontNFAcopy -> Status[ i ];
        }else{
            j = frontNFA -> numOfStatus ;
            combined_NFA->Status[ i ] = tailNFAcopy -> Status[ i-j ];
        }
    }

    /* ID 问题 */
    for( i = 0; i < combined_NFA->numOfStatus; i++ )
        combined_NFA->Status[ i ] -> ID = i;

    storeAllEdges( combined_NFA ) ;
    
    return combined_NFA ;
}

NFA *Union ( NFA *nfa1, NFA *nfa2 )
{
    int i, j;
    NFA  *combineNFA, *nfa1copy, *nfa2copy ;
    Status *start, *end ;
    Edge *e1_start, *e2_start ;
    Edge *e1_end, *e2_end ;

    nfa1copy = CopyNFA( nfa1 ) ;
    nfa2copy = CopyNFA( nfa2 ) ;
    nfa1copy -> end -> FinalStatus = false;
    nfa2copy -> end -> FinalStatus = false;

    start = malloc( sizeof( Status ) );
    end   = malloc( sizeof( Status ) );

    e1_start = allocEpsilonEdge( );
    e2_start = allocEpsilonEdge( );
    e1_end = allocEpsilonEdge( );
    e2_end = allocEpsilonEdge( );

    linkTwoStatus_by_AnEdge( start, nfa1copy -> start, e1_start);
    linkTwoStatus_by_AnEdge( start, nfa2copy -> start, e2_start);
    
    linkTwoStatus_by_AnEdge( nfa1copy -> end, end , e1_end );
    linkTwoStatus_by_AnEdge( nfa2copy -> end, end , e2_end );

    combineNFA = malloc( sizeof( NFA ) );
    combineNFA -> start = start ;
    combineNFA -> end   = end ;
    combineNFA -> end -> FinalStatus = true ;

    /* 构造合成nfa的状态数组 */
    combineNFA -> numOfStatus = 2 + nfa1copy->numOfStatus + nfa2copy->numOfStatus ;
    combineNFA -> Status = malloc( sizeof(Status*) * combineNFA->numOfStatus );
    
    /* 初始化nfa状态数组的第一个状态 */
    combineNFA -> Status[0] = start ;
    for( i = 1; i < combineNFA->numOfStatus; i ++ )
    {
        if( i < nfa1copy -> numOfStatus )
        {
            combineNFA -> Status[ i ] = nfa1copy -> Status[ i ];
        }else{
            j = frontNFA -> numOfStatus ;
            combineNFA->Status[ i ] = nfa2copy -> Status[ i-j ];
        }
    }
    combineNFA -> Status[ combineNFA->numOfStatus-1 ] = end ;

    for( i = 0; i < combineNFA->numOfStatus; i++ )
        combineNFA -> Status[ i ] -> ID = i;

    // 储存边集合 
    {
    combineNFA -> numOfEdges = nfa1copy->numOfEdges + nfa2copy->numOfEdges + 4;
    combineNFA -> edgeArray = malloc( sizeof(Edge*) * combineNFA->numOfEdges );

    combineNFA -> edgeArray[ 0 ] = e1_start;
    combineNFA -> edgeArray[ 1 ] = e2_start;

    for( i = 0; i < nfa1copy -> numOfEdges; i++ )
        combineNFA -> edgeArray[ i+2 ] = nfa1copy -> edgeArray[ i ];
    
    for( i = 0; i < nfa2copy -> numOfEdges; i++ )
        combineNFA -> edgeArray[ i+2+nfa1copy->numOfEdges ] = nfa2copy -> edgeArray[ i ] ;

    combineNFA -> edgeArray[ nfa1copy->numOfEdges + nfa2copy->numOfEdges + 2 ] = e1_end;
    combineNFA -> edgeArray[ nfa1copy->numOfEdges + nfa2copy->numOfEdges + 3 ] = e2_end;
    }
    //storeAllEdges( combineNFA ) ;
    return combineNFA ;
}

NFA 
*Closure( NFA *nfa )
{
    Edge *start_to_nfastart, *nfaEnd_to_nfastart, *nfaEnd_to_end, *start_to_end;
    Status *start, *end ;
    NFA *nfacopy;
    NFA *newnfa;

    nfacopy = CopyNFA(nfa);
    

    return newnfa ;
}


NFA *RegexpToNFA(
        xchar_t *regExp
        )
{
    int     i, SizeOfExp ;
    NFA     *nfaStack[ MAXLEN_REGEXP ], *newnfa ;
    Edge    *e ;
    xchar_t opeStack[ MAXLEN_REGEXP ] ;
    int     nfatop ;
    int     opetop ;
    xchar_t ch ;
    xchar_t sh ;

    nfatop = opetop = 0 ;
    SizeOfExp = wcslen( regExp ) ;
    /* 初始化静态变量 */
    PriorityInit( );

    for( i = 0; i < SizeOfExp; i++ )
    {
        ch = regExp[ i ] ;
        sh = opeStack[ opetop ] ;
        if( isOperator( ch ) ){
            
            if( OutPriority( ch ) > InPriority( sh ) )
            {
                /* 分析从栈顶提取的运算符 */
                
            }else{
                opeStack[ opetop ++ ] = ch ;
            }
        } else {
            newnfa  = CreateOneNFA( ch );
            e = newnfa -> start -> OutEdges[0] ;
            e -> matchContent = malloc( sizeof( xchar_t ) * 1 );
            e -> matchContent[ 0 ] = ch ;
            /* 将newnfa压入nfa栈 */
            nfaStack[ nfatop ++ ] = newnfa ;
        }
    }
    /* 预计的结果： nfa栈中最后只剩一个nfa */
    return nfaStack[ 0 ] ;
}

int isOperator( xchar_t c )
{
    if( c=='(' || c==')' || c=='*' ||
        c=='+' || c=='?' || c=='.' ||
        c=='|' )
        return 1 ;
    else
        return 0 ;
}

/* 能自动扫描表示范围的正则表达式，
 * 返回一个NFA, 并且能够将扫描器前移
 *  到 ']' 后。 */
NFA *ScanRangeAndReturnNFA( )
{
    // 当前current_RegExp_Index 指向"["字符。
    xchar_t nextChar, currChar ;
    bool    outOfrange ;
    Index   i         ;
    int     sizeofReg ;
    NFA     *nfa ;
    Edge    *onlyEdge ;
    Range   range ;
    Range   rangeBuffer[ MAXLEN_REGEXP / 3 ] ;
    xchar_t contentBuffer[ MAXLEN_REGEXP ] ;
    int     size_RangeBuffer ;
    int     size_ContentBuffer ;

    i = current_RegExpArray_Index ;
    sizeofReg = wcslen( RegExp[ i ] ) ;
    size_RangeBuffer = 0 ;
    size_ContentBuffer = 0;

    current_RegExp_Index ++ ;

    if( RegExp[ i ][ current_RegExp_Index ] == L'^' ) {
        outOfrange = true ;
        current_RegExp_Index ++ ;
    }else{
        outOfrange = false ;
    }
    
    while( RegExp[ i ][ current_RegExp_Index ] != L']' )
    {

        currChar = RegExp[ i ][ current_RegExp_Index ] ;

        if( current_RegExp_Index + 1 >= sizeofReg ) {
            printf( "the regular expression doesn't ends with ']'\n" );
            printf( ",while a part of it begins with a '['\n" );
            while( getchar() ){}
        }     
        nextChar = RegExp[ i ][ current_RegExp_Index + 1 ] ;

        if( nextChar == L'-' ){
            if( current_RegExp_Index + 2 >= sizeofReg ){
                // 越界
                current_RegExp_Index ++ ;
                continue ;
            }
            else if( RegExp[ i ][ current_RegExp_Index + 2 ] == L']' ) 
            {
                contentBuffer[ size_ContentBuffer ++ ] = currChar ;
                contentBuffer[ size_ContentBuffer ++ ] = nextChar ;
                current_RegExp_Index += 2 ;
            } else {
                // range = malloc( sizeof( Range ) ) ;
                range.from = currChar ;
                range.to = RegExp[ i ][ current_RegExp_Index + 2 ] ;
                
                /* 将得到的范围储存到一个数组中 */
                rangeBuffer[ size_RangeBuffer ++ ] = range ;

                current_RegExp_Index += 3 ;
            }
        }else {
            contentBuffer[ size_ContentBuffer ++ ] = currChar ;
            current_RegExp_Index ++ ;       
        }
    }
    contentBuffer[ size_ContentBuffer ] = '\0';

    onlyEdge = malloc( sizeof(Edge) );
    if( !onlyEdge ) {
        nfa = NULL ;
        printf(" no memory\n ");
        return nfa ;
    }

    if( outOfrange == true )
    {
        onlyEdge -> numOfInMatchRange = size_RangeBuffer ;

        onlyEdge -> inMatchRange = malloc( 
                            size_RangeBuffer * sizeof( Range )
                        );

        for( i = 0; i < onlyEdge -> numOfInMatchRange; i ++ )
            onlyEdge -> inMatchRange[ i ] = rangeBuffer[ i ];
        
        onlyEdge -> inMatchContent = 
                malloc( sizeof( xchar_t ) * (size_ContentBuffer+1) ) ;

        wcscpy( onlyEdge -> inMatchContent, contentBuffer );
    } else {
        onlyEdge -> numOfMatchRange = size_RangeBuffer ;

        onlyEdge -> matchRange = malloc( 
                            sizeof(Range) * onlyEdge->numOfMatchRange 
                        );

        for( i = 0; i < onlyEdge -> numOfMatchRange; i ++ )
            onlyEdge -> matchRange[ i ] = rangeBuffer[ i ];
        
        onlyEdge -> matchContent = 
                malloc( sizeof( xchar_t ) * (size_ContentBuffer+1) ) ;
        wcscpy( onlyEdge -> matchContent, contentBuffer );
    }

    Status *start, *end;
    start = malloc( sizeof( Status ) ) ;
    end   = malloc( sizeof( Status ) ) ;
   
    start -> ID = 1 ;
    start -> numOfOutEdges = 1 ;
    start -> OutEdges = malloc( sizeof( Edge* ) * start->numOfOutEdges );
    start->OutEdges[0] = onlyEdge ;

    end -> ID = 2 ;
    end -> numOfInEdges = 1 ;
    end -> InEdges = malloc( sizeof( Edge* ) * end->numOfOutEdges  );
    end -> InEdges[0] = onlyEdge ;
    end -> FinalStatus = true ;
    
    nfa = malloc( sizeof( NFA ) ) ;    
    nfa -> start = start ;
    nfa -> end   = end ;

    return nfa ;
}

void EdgeArrayAppend( Edge ***edgeArray, int *Size, Edge *newEdge )
{
    if( *Size == 0 )
    {
        *edgeArray = malloc( sizeof(Edge*) );
        *edgeArray[ 0 ] = newEdge ;
        *Size = *Size + 1;
    }
    else
    {
        *edgeArray = realloc( *edgeArray, sizeof(Edge*) );
        *edgeArray[ *Size ] = newEdge ;
        *Size = *Size + 1;
    }
}


NFA *CopyNFA( NFA * nfa )
{
    int i, id ;
    NFA *copyNFA ;
    Edge *e, **InEdges, **OutEdges ;
    Status *fromStatus, *toStatus;

    copyNFA = malloc( sizeof( NFA ) );
    /* 首先，复制nfa状态数组中所有状态数组，除InEdges和OutEdges */
    copyNFA -> numOfStatus = nfa -> numOfStatus ;
    copyNFA -> Status = malloc( sizeof( Status* ) * copyNFA->numOfStatus );
    for( i = 0; i < copyNFA -> numOfStatus; i++ )
    {
        copyNFA -> Status[ i ] = allocStatus(); 
        copyNFA -> Status[ i ]->ID = i;
        copyNFA -> Status[ i ] -> numOfInEdges = 0 ;
        copyNFA -> Status[ i ] -> InEdges = NULL ;
        copyNFA -> Status[ i ] -> numOfOutEdges = 0 ;
        copyNFA -> Status[ i ] -> OutEdges = NULL ;
    }

    /* 第二步，复制所有边(除了指向前后Status的储存单元 */
    copyNFA -> numOfEdges = nfa -> numOfEdges ;
    copyNFA -> edgeArray = malloc( sizeof( Edge* ) * copyNFA->numOfEdges );
    for( i = 0; i < copyNFA -> numOfEdges; i++ )
    {
        copyNFA -> edgeArray[ i ] = CopyEdge( nfa->edgeArray[i] );
        /* set from_Status for E[i] */
        id = nfa -> edgeArray[i] -> from_Status -> ID ;
        copyNFA -> edgeArray[ i ] -> from_Status = copyNFA->Status[ id ];
        
        /* set to_Status for E[i] */
        id = nfa -> edgeArray[i] -> to_Status -> ID ;
        copyNFA -> edgeArray[ i ] -> to_Status = copyNFA->Status[ id ];

    }

    /* 第三部，针对edgeArray的每一条边，生成每个Status的InEdges和OutEdges */
    for( i = 0; i < copyNFA -> numOfEdges; i++ )
    {
        e = copyNFA -> edgeArray[ i ] ;
        fromStatus = e -> from_Status;
        toStatus = e -> to_Status ;

        /* 更新fromStatus 的OutEdges */
        id = fromStatus -> ID ;
        if( fromStatus -> numOfOutEdges == 0 )
            fromStatus -> OutEdges = malloc( sizeof(Edge*) * 1 );
        else
            fromStatus -> OutEdges = realloc( fromStatus->OutEdges, sizeof(Edge*) );
        fromStatus -> OutEdges[ fromStatus->numOfOutEdges ++ ] = e;

        //EdgeArrayAppend(&copyNFA->Status[id]->OutEdges,&(copyNFA -> Status[id] -> numOfOutEdges),e);
        
        id = toStatus -> ID ;
        //EdgeArrayAppend(&copyNFA -> Status[id] -> InEdges,&(copyNFA -> Status[id] -> numOfInEdges),e);
        if( toStatus -> numOfInEdges == 0 )
            toStatus -> InEdges = malloc( sizeof(Edge*) ) ;
        else
            toStatus -> InEdges = realloc( toStatus->InEdges, sizeof(Edge*) );
        toStatus -> InEdges[ toStatus->numOfInEdges ++ ] = e;
        
    }

    /* 最后，更新start 和 end */
    copyNFA -> start = copyNFA -> Status[ 0 ] ;
    copyNFA -> end   = copyNFA -> Status[ copyNFA->numOfStatus-1 ] ;
    copyNFA -> end -> FinalStatus = true ;
    return copyNFA ;

}

Edge *CopyEdge( Edge *e )
{
    Edge *newedge ;
    newedge = malloc( sizeof( Edge ) );
    /* 值拷贝 */
    *newedge = *e ;
    newedge -> from_Status = newedge -> to_Status = NULL ;

    if( e->matchContent != NULL )
        wcscpy( newedge->matchContent, e->matchContent );

    if( e->inMatchContent != NULL )
        wcscpy( newedge -> inMatchContent, e -> inMatchContent ) ;
        
    RangeCopy( newedge -> matchRange , e->matchRange, e->numOfMatchRange) ;
    RangeCopy( newedge -> inMatchRange, e->inMatchRange, e->numOfInMatchRange ) ; 
    
    return newedge ;

}



void RangeCopy(
                Range *toRangeArray,
                Range *fromRangeArray,
                int size
            )
{
    int i ;
    if( size <= 0 )
        return ;
    toRangeArray = malloc( sizeof( Range ) * size ) ;
    isNullPointer( toRangeArray ) ;

    for( i = 0; i < size; i++ )
        toRangeArray[ i ] = fromRangeArray[ i ];
}
